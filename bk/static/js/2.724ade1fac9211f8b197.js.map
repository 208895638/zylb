{"version":3,"sources":["webpack:///./node_modules/_vue-codemirror@4.0.6@vue-codemirror/dist/vue-codemirror.js","webpack:///./node_modules/_babel-runtime@6.26.0@babel-runtime/helpers/asyncToGenerator.js","webpack:///./node_modules/_codemirror@5.49.2@codemirror/lib/codemirror.js","webpack:///src/pages/post/single.vue","webpack:///./src/pages/post/single.vue?9d93","webpack:///./src/pages/post/single.vue","webpack:///./node_modules/_regenerator-runtime@0.11.1@regenerator-runtime/runtime-module.js","webpack:///./node_modules/_codemirror@5.49.2@codemirror/mode/javascript/javascript.js","webpack:///./node_modules/_regenerator-runtime@0.11.1@regenerator-runtime/runtime.js","webpack:///./node_modules/_babel-runtime@6.26.0@babel-runtime/regenerator/index.js"],"names":["t","e","r","n","exports","o","i","l","call","m","c","d","Object","defineProperty","configurable","enumerable","get","__esModule","default","prototype","hasOwnProperty","p","s","value","window","CodeMirror","assign","TypeError","arguments","length","writable","name","data","content","codemirror","cminstance","props","code","String","marker","Function","unseenLines","Array","type","placeholder","merge","Boolean","options","events","globalOptions","globalEvents","watch","deep","handler","this","setOption","$nextTick","switchMerge","handerCodeChange","methods","initialize","MergeView","$refs","mergeview","edit","fromTextArea","textarea","setValue","on","getValue","$emit","concat","filter","forEach","apply","replace","toLowerCase","unseenLineMarkers","refresh","destroy","doc","cm","getWrapperElement","remove","getScrollInfo","scrollTo","left","top","lineInfo","setGutterMarker","gutterMarkers","history","cleanGeneration","mounted","beforeDestroy","indexOf","a","install","u","component","render","staticRenderFns","_compiled","functional","_scopeId","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","f","beforeCreate","_injectStyles","esModule","$createElement","_self","_c","staticClass","class","ref","attrs","module","__webpack_require__","obj","_promise","_promise2","fn","gen","resolve","reject","step","key","arg","info","error","done","then","err","factory","userAgent","navigator","platform","gecko","test","ie_upto10","ie_11up","exec","edge","ie","ie_version","document","documentMode","webkit","qtwebkit","chrome","presto","safari","vendor","mac_geMountainLion","phantom","ios","android","mobile","mac","chromeOS","windows","presto_version","match","Number","flipCtrlCmd","captureRightClick","classTest","cls","RegExp","range","rmClass","node","current","className","after","slice","index","removeChildren","count","childNodes","removeChild","firstChild","removeChildrenAndAdd","appendChild","elt","tag","style","createElement","cssText","createTextNode","eltP","setAttribute","contains","child","nodeType","parentNode","host","activeElt","activeElement","body","shadowRoot","addClass","joinClasses","b","as","split","createRange","start","end","endNode","setEnd","setStart","createTextRange","moveToElementText","collapse","moveEnd","moveStart","selectInput","select","bind","args","copyObj","target","overwrite","prop","countColumn","string","tabSize","startIndex","startValue","search","nextTab","selectionStart","selectionEnd","_e","Delayed","id","time","onTimeout","array","self","Date","setTimeout","set","ms","clearTimeout","scrollerGap","Pass","toString","sel_dontScroll","scroll","sel_mouse","origin","sel_move","findColumn","goal","pos","col","skipped","Math","min","spaceStrs","spaceStr","push","lst","arr","map","out","nothing","createObj","base","inst","create","nonASCIISingleCaseWordChar","isWordCharBasic","ch","toUpperCase","isWordChar","helper","source","isEmpty","extendingChars","isExtendingChar","charCodeAt","skipExtendingChars","str","dir","charAt","findFirst","pred","from","to","midF","mid","ceil","floor","bidiOther","getBidiPartAt","order","sticky","found","cur","bidiOrdering","lowTypes","arabicTypes","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","BidiSpan","level","direction","outerType","len","types","i$1","prev","i$2","type$1","i$3","prev$1","type$2","i$4","type$3","j","i$5","cur$1","type$4","i$6","end$1","before","replace$1","j$1","i$7","at","j$2","splice","nstart","unshift","reverse","getOrder","line","text","noHandlers","emitter","addEventListener","attachEvent","map$$1","_handlers","getHandlers","off","removeEventListener","detachEvent","signal","handlers","signalDOMEvent","override","preventDefault","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","cursorActivity","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","e_preventDefault","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_stop","e_target","srcElement","e_button","which","button","ctrlKey","zwspSupported","badBidiRects","dragAndDrop","div","zeroWidthElement","measure","offsetHeight","offsetWidth","hasBadBidiRects","txt","r0","getBoundingClientRect","r1","right","splitLinesAuto","result","nl","rt","hasSelection","getSelection","te","range$$1","ownerDocument","selection","parentElement","compareEndPoints","hasCopyEvent","oncopy","badZoomedRects","modes","mimeModes","resolveMode","spec","getMode","mfactory","modeObj","modeExtensions","exts","helperType","modeProps","prop$1","extendMode","mode","properties","copyState","state","nstate","val","innerMode","startState","a1","a2","StringStream","lineOracle","lastColumnPos","lastColumnValue","lineStart","getLine","first","size","Error","chunk","lines","children","sz","chunkSize","getBetween","iter","getLines","updateLineHeight","height","diff","lineNo","no","lineAtHeight","h","outer","lh","isLine","lineNumberFor","lineNumberFormatter","firstLineNumber","Pos","cmp","equalCursorPos","copyPos","x","maxPos","minPos","clipLine","max","clipPos","last","linelen","clipToLen","clipPosArray","eol","sol","peek","undefined","next","eat","eatWhile","eatSpace","skipToEnd","skipTo","backUp","column","indentation","pattern","consume","caseInsensitive","cased","substr","hideFirstChars","inner","lookAhead","oracle","baseToken","SavedContext","Context","maxLookAhead","baseTokens","baseTokenPos","highlightLine","context","forceToEnd","st","modeGen","lineClasses","runMode","loop","overlay","overlays","i_end","opaque","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getContextBefore","resetState","maxHighlightLength","stateAfter","save","styleClasses","highlightFrontier","modeFrontier","precise","display","minindent","minline","lim","indented","findStartLine","saved","fromSaved","processLine","viewFrom","viewTo","nextLine","startAt","stream","callBlankLine","readToken","blankLine","token","copy","Token","takeToken","asArray","tokens","extractLineClasses","output","lineClass","flattenSpans","curStart","curStyle","addModeClass","mName","sawReadOnlySpans","sawCollapsedSpans","MarkedSpan","getMarkedSpanFor","spans","span","removeMarkedSpan","stretchSpansOverChange","change","full","oldFirst","markedSpans","oldLast","startCh","endCh","isInsert","old","nw","inclusiveLeft","insertLeft","endsAfter","inclusiveRight","markedSpansBefore","startsBefore","markedSpansAfter","sameLine","offset","span$1","clearEmptySpans","newMarkers","gapMarkers","gap","clearWhenEmpty","detachMarkedSpans","detachLine","attachMarkedSpans","attachLine","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","find","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","collapsedSpanAround","conflictingCollapsedRange","lineNo$$1","visualLine","merged","visualLineNo","lineN","vis","visualLineEndNo","lastLine","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","found$1","findMaxLine","maxLine","maxLineLength","maxLineChanged","Line","estimateHeight","cleanUpLine","styleToClassCache","styleToClassCacheWithMode","interpretTokenStyle","cache","buildLineContent","lineView","builder","pre","trailingSpace","splitSpaces","getOption","rest","addToken","buildToken","buildTokenBadBidi","insertLineContent","externalMeasured","maps","caches","lastChild","querySelector","defaultSpecialCharPlaceholder","title","startStyle","endStyle","css","attributes","displayText","trailingBefore","spaceBefore","special","specialChars","mustWrap","createDocumentFragment","lastIndex","txt$1","tabWidth","specialCharPlaceholder","fullStyle","attr","part","buildCollapsedSpan","ignoreWidget","widget","input","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","Infinity","foundBookmarks","endStyles","upto","tokenText","LineView","visualLineContinued","hidden","buildViewArray","nextPos","view","operationGroup","orphanDelayedCallbacks","signalLater","list","delayedCallbacks","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","zIndex","getLineContent","ext","built","background","wrap","insertBefore","updateLineBackground","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","markers","lineNumbers","wrap$1","gutterWrap","lineNumber","gutterLeft","k","gutterSpecs","gutterWidth","alignable","nextSibling","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","width","wrapperWidth","coverGutter","paddingLeft","position","marginLeft","widgetHeight","parentStyle","gutters","wrapper","clientWidth","eventInWidget","getAttribute","sizer","mover","paddingTop","lineSpace","offsetTop","paddingVert","paddingH","cachedPaddingH","getComputedStyle","currentStyle","parseInt","paddingRight","isNaN","scrollGap","nativeBarWidth","displayWidth","scroller","barWidth","displayHeight","clientHeight","barHeight","mapFromLineView","measureChar","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","getDimensions","forceUpdate","lineMeasure","updateExternalMeasurement","rect","hasHeights","prepared","varHeight","wrapping","lineWrapping","curWidth","heights","rects","getClientRects","abs","bottom","ensureLineHeights","place","nodeAndOffsetInLineMap","coverStart","coverEnd","getUsefulRect","screen","logicalXDPI","deviceXDPI","normal","fromRange","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","maybeUpdateRectForZooming","rSpan","charWidth","nullRect","rtop","rbot","bot","bogus","singleCursorHeightPerLine","rbottom","measureCharInner","measureText","mStart","mEnd","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","cachedCharWidth","cachedTextHeight","lineNumChars","pageScrollX","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","widgetTopHeight","intoCoordSystem","includeWidgets","yOff","viewOffset","lOff","xOff","fromCoordSystem","coords","localBox","lineSpaceBox","charCoords","cursorCoords","preparedMeasure","getBidi","partPos","invert","other","estimateCoords","PosWithInfo","outside","xRel","coordsChar","y","coordsCharInner","rangeEnd","wrappedLineExtent","begin","wrappedLineExtentChar","boxIsAfter","box","widgetHeight$$1","ltr","_lineNo","closestDist","endX","dist","baseX","chAround","boxAround","atLeft","atStart","textHeight","anchor","clientLeft","offsetLeft","compensateForHScroll","th","perLine","widgetsHeight","estimateLineHeights","est","estHeight","posFromMouse","liberal","forRect","space","clientX","clientY","colDiff","round","regChange","lendiff","updateLineNumbers","viewChanged","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","countDirtyView","dirty","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","sel","ranges","primIndex","empty","showCursorWhenSelecting","drawSelectionCursor","head","drawSelectionRange","cursor","cursorHeight","otherCursor","cmpCoords","fragment","padding","leftSide","rightSide","sizerWidth","docLTR","drawForLine","fromArg","toArg","lineLen","wrapX","side","extent","iterateBidiSections","fromPos","toPos","openStart","openEnd","openRight","topLeft","topRight","botLeft","botRight","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","focused","clearInterval","blinker","cursorDiv","visibility","cursorBlinkRate","setInterval","ensureFocus","focus","onFocus","delayBlurEvent","delayingBlurEvent","onBlur","readOnly","selForContextMenu","reset","receivedFocus","shift","updateHeightsInViewport","prevBottom","lineDiv","updateWidgetHeight","chWidth","w","visibleLines","viewport","ensure","ensureFrom","ensureTo","calculateScrollPos","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","getCursor","scrollToPos","margin","cursorScrollMargin","scrollToCoords","scrollToCoordsRange","sPos","updateScrollTop","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollHeight","scrollbars","setScrollLeft","isScroller","scrollWidth","alignHorizontally","measureForScrollbars","gutterW","docH","viewHeight","viewWidth","barLeft","docHeight","NativeScrollbars","vert","horiz","tabIndex","checkedZeroWidth","minHeight","minWidth","update","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","pointerEvents","bar","delay","maybeDisable","elementFromPoint","clear","NullScrollbars","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","paddingBottom","heightForcer","borderBottom","scrollbarFiller","coverGutterNextToScrollbar","gutterFiller","scrollbarModel","native","null","initScrollbars","scrollbarStyle","axis","nextOpId","startOperation","op","updateInput","typing","changeObjs","cursorActivityCalled","selectionChanged","updateMaxLine","ops","ownsGroup","endOperation","endCb","group","callbacks","fireCallbacksForOps","finishOperation","endOperation_R1","updatedDisplay","mustUpdate","updateDisplayIfNeeded","endOperation_R2","endOperation_W2","endOperation_finish","endOperations","scrollbarsClipped","marginBottom","borderRightWidth","maybeClipScrollbars","DisplayUpdate","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","takeFocus","setDocumentHeight","postUpdateDisplay","wheelStartX","wheelStartY","doScroll","innerHeight","scrollNode","scrollIntoView","maybeScrollWindow","limit","changed","endCoords","scrollPos","startTop","startLeft","scrollPosIntoView","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","operation","methodOp","docMethodOp","highlight","highlightWorker","workTime","changedLines","oldStyles","highlighted","oldCls","newCls","ischange","workDelay","force","visible","editorIsHidden","wrapperHeight","oldDisplayWidth","renderedView","maybeUpdateLineNumberWidth","viewportMargin","different","lastWrapHeight","lastWrapWidth","adjustView","toUpdate","selSnapshot","hasFocus","active","anchorNode","extend","anchorOffset","focusNode","focusOffset","selectionSnapshot","updateNumbersFrom","container","rm","currentWheelTarget","updateNumber","patchDisplay","snapshot","removeAllRanges","addRange","restoreSelection","selectionDiv","reportedViewFrom","reportedViewTo","updateGutterSpace","alignWidgets","comp","align","innerW","lineGutter","lineNumInnerWidth","lineNumWidth","getGutters","sawLineNumbers","renderGutters","specs","gElt","updateGutters","wheelSamples","wheelPixelsPerUnit","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","delta","onScrollWheel","canScrollX","canScrollY","pixels","wheelDX","wheelDY","movedX","movedY","sample","Selection","equals","here","there","deepCopy","Range","somethingSelected","normalizeSelection","mayTouch","selectionsMayTouch","prim","sort","inv","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","estimateHeight$$1","spansFor","updateLine","linesFor","firstLine","lastText","lastSpans","nlines","insert","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","rel","shared","attachDoc","setDirectionClass","History","startGen","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","pop","addChangeToHistory","selAfter","opId","hist","historyEventDelay","lastChangeEvent","pushSelectionToHistory","addSelectionToHistory","selectionEventCanBeMerged","clearRedo","dest","existing","removeClearedSpans","explicitlyCleared","mergeOldSpans","getOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","newGroup","instantiateSel","event","newChanges","extendRange","posBefore","extendSelection","setSelection","extendSelections","heads","replaceOneSelection","setSimpleSelection","setSelectionReplaceHistory","setSelectionNoUndo","NaN","filterSelectionChange","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","preventCursorLeft","selectLeft","preventCursorRight","selectRight","atomic","near","movePos","far","cantEdit","selectAll","filterChange","canceled","cancel","makeChange","ignoreReadOnly","suppressEdits","mark","parts","mk","newParts","dfrom","dto","removeReadOnlyRanges","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","suppress","antiChanges","returned","v","shiftDoc","distance","removed","recomputeMaxLength","checkWidthStart","retreatFrontier","changesHandler","changeHandler","makeChangeSingleDocInEditor","replaceRange","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","changeLine","handle","changeType","LeafChunk","BranchChunk","removeInner","insertInner","iterN","oldHeight","remaining","leaf","maybeSpill","me","sibling","myIndex","used","LineWidget","opt","adjustScrollWhenAboveVisible","this$1","oldH","nextMarkerId","TextMarker","markText","cloneNode","isParent","SharedTextMarker","markTextShared","replacedWith","addToHistory","curLine","addMarkedSpan","clearOnEnter","clearHistory","withOp","visual","dHeight","findSharedMarkers","findMarks","detachSharedMarkers","subMarker","nextDocId","Doc","lineSep","constructor","join","lineSeparator","getRange","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","listSelections","setCursor","extendSelectionsBy","setSelections","addSelection","getSelections","replaceSelection","dup","replaceSelections","newSel","hint","oldPrev","newPrev","computeReplacedSel","undo","redo","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","getHistory","setHistory","histData","gutterID","clearGutter","addLineClass","where","removeLineClass","addLineWidget","insertAt","aboveVisible","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","mFrom","mTo","subMark","copySharedMarkers","unlinkDoc","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","lastDrop","onDrop","clearDragCursor","files","dataTransfer","isReadOnly","FileReader","File","read","loadFile","file","allowDropFileTypes","reader","onload","readAsText","draggingText","text$1","getData","selected","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","editors","globalsRegistered","ensureGlobalHandlers","resizeTimer","onResize","setSize","keyNames","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","145","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","fromCharCode","keyMap","normalizeKeyName","alt","ctrl","cmd","mod","normalizeKeyMap","keymap","keyname","keys","lookupKey","getKeyMap","fallthrough","isModifierKey","keyCode","addModifierNames","noShift","altKey","metaKey","shiftKey","keyName","altGraphKey","deleteNearSelection","compute","kill","toKill","replaced","moveCharLogically","moveLogically","endOfLine","visually","prep","targetTop","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","commands","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","rightPos","goDocStart","goDocEnd","goLineStart","goLineStartSmart","lineStartSmart","goLineEnd","visualLineEnd","lineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertTab","insertSoftTab","spaces","defaultTab","execCommand","transposeChars","newlineAndIndent","sels","indentLine","openLine","toggleOverwrite","firstNonWS","inWS","doHandleBinding","bound","dropShift","ensurePolled","prevShift","stopSeq","dispatchKey","seq","keySeq","dispatchKeyInner","keyMaps","extraKeys","lookupKeyForEditor","handleKeyBinding","motion","lastStoppedKey","onKeyDown","handled","up","showCrossHair","onKeyUp","onKeyPress","charCode","handleCharBinding","lastClick","lastDoubleClick","PastClick","onMouseDown","activeTouch","supportsTouch","draggable","clickInGutter","repeat","now","compare","clickRepeat","selectingText","handleMappedButton","contained","behavior","option","unit","addNew","moveOnDrag","configureMouse","dragDrop","moved","dragEnd","mouseMove","dragStart","e2","leftButtonStartDrag","ourRange","ourIndex","startSel","rangeForUnit","lastPos","extendTo","startCol","posCol","leftPos","oldRange","ranges$1","anchorLine","boundary","headIndex","usePart","bidiSimplify","editorSize","counter","move","buttons","curCount","leftButtonSelect","leftButtonDown","onContextMenu","findWordAt","gutterEvent","prevent","mX","mY","touches","lineBox","g","contextMenuInGutter","themeChanged","theme","Init","defaults","optionHandlers","dragDropChanged","funcs","dragFunctions","toggle","enter","over","leave","drop","wrappingChanged","inputStyles","inputStyle","init","pasteIncoming","cutIncoming","autofocus","word","touchFinished","prevTouch","finishTouch","farAway","touch","radiusX","radiusY","isMouseLikeTouchEvent","pageX","pageY","frag","onDragOver","setData","effectAllowed","setDragImage","img","src","_top","onDragStart","inp","getField","registerEventHandlers","finishInit","initHooks","textRendering","how","aggressive","indent","curSpace","curSpaceString","indentUnit","indentString","indentWithTabs","pos$1","defineInitHook","lastCopied","setLastCopied","newLastCopied","applyTextInput","inserted","deleted","recent","paste","textLines","multiPaste","pasteLinesPerSelection","lineWise","changeEvent","triggerElectric","handlePaste","pasted","clipboardData","disableInput","electricChars","smartIndent","getModeAt","electricInput","copyableRanges","lineRange","disableBrowserMagic","field","spellcheck","autocorrect","autocapitalize","hiddenTextarea","border","findPosH","origDir","moveOnce","boundToLine","bidi","mv","getWrappedLineExtent","moveInStorageOrder","searchInVisualLine","getRes","res","nextCh","moveVisually","sawType","getHelper","hitSide","findPosV","pageSize","moveAmount","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","posToDOM","badPos","bad","domToPos","lineNode","locateNodeInLineView","textNode","topNode","nodeValue","curNode","textContent","previousSibling","dist$1","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","updateFromDOM","readFromDOMSoon","forceCompositionEnd","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","blur","pollSelection","pollInterval","poll","scan","isInGutter","triggerOnKeyDown","pollContent","fromIndex","fromNode","toNode","toIndex","newText","closing","extraLinebreak","close","addText","walk","cmText","markerID","isBlock","nodeName","domTextBetween","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","readOnlyChanged","resetPosition","TextareaInput","prevInput","pollingFast","createField","prepareCopyCut","fastPoll","dispatchEvent","Event","_display","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","slowPoll","missed","same","resetSelectionOnContextMenu","oldScrollY","oldCSS","oldWrapperCSS","wrapperBox","offsetParent","scrollY","rehide","detectingSelectAll","prepareSelectAllHack","mouseup","extval","disabled","deflt","notOnInit","defineOption","newBreaks","getInputField","detach","attach","integer","defineOptions","helpers","getDoc","addKeyMap","removeKeyMap","addOverlay","score","priority","insertSorted","modeSpec","removeOverlay","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","help","_global","getStateAfter","defaultTextHeight","defaultCharWidth","getViewport","addWidget","vspace","hspace","triggerOnKeyPress","triggerOnKeyUp","triggerOnMouseDown","amount","rtlMoveVisually","goalColumn","goals","startChar","check","scrollToRange","interpret","swapDoc","phrase","phraseText","phrases","getScrollerElement","getGutterElement","registerHelper","registerGlobalHelper","predicate","addEditorMethods","dontDelegate","method","contenteditable","defineMode","dependencies","defineMIME","mime","defineExtension","func","defineDocExtension","tabindex","realSubmit","form","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","toTextArea","cmpPos","addLegacyProps","version","single","msg","author","publishDate","viewCount","fullscreenLoading","rate","email","url","desc","cmOptions","components","aside","foot","footer","vue_codemirror","fetchData","_this","asyncToGenerator_default","regenerator_default","_callee","_context","$route","params","t0","abrupt","stop","getcomponentmsg","alert","showPayBox","$alert","dangerouslyUseHTMLString","onSubmit","post_single","_vm","_h","showmsg","_v","separator","path","href","_s","domProps","innerHTML","show-text","model","callback","$$v","expression","icon","click","label-width","label","$set","Component","normalizeComponent","__webpack_exports__","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","config","parserConfig","statementIndent","jsonldMode","jsonld","jsonMode","json","isTS","typescript","wordRE","wordCharacters","keywords","kw","A","B","C","D","operator","atom","if","while","with","else","do","try","finally","return","break","continue","new","delete","void","throw","debugger","var","const","let","function","catch","for","switch","case","in","typeof","instanceof","true","false","super","yield","export","import","extends","await","isOperatorChar","isJsonldKeyword","ret","tp","cont","tokenBase","quote","tokenize","escaped","tokenComment","expressionAllowed","inSet","readRegexp","tokenQuasi","lexical","lastType","propertyIsEnumerable","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","depth","sawSomething","bracket","atomicTypes","number","variable","regexp","jsonld-keyword","JSLexical","inScope","varname","localVars","cx","vars","marked","cc","pass","inList","register","block","newContext","registerVarScoped","Var","globalVars","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","lex","poplex","expect","wanted","exp","statement","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","enumdef","typename","typeexpr","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","targetNoComma","maybeTypeArgs","maybeTarget","expr","property","continueQuasi","_","getterSetter","afterprop","maybetype","what","sep","proceed","maybetypeOrIn","mayberettype","isKW","afterType","typeprop","typearg","maybeReturnType","functiondecl","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","basecolumn","parseJS","textAfter","firstChar","isContinuedStatement","doubleIndentSwitch","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","fold","closeBrackets","skipExpression","global","Op","hasOwn","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","GenStateSuspendedStart","GenStateSuspendedYield","GenStateExecuting","GenStateCompleted","ContinueSentinel","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","GeneratorFunctionPrototype","Generator","GeneratorFunction","displayName","isGeneratorFunction","genFun","setPrototypeOf","__proto__","awrap","__await","defineIteratorMethods","AsyncIterator","async","innerFn","outerFn","tryLocsList","object","skipTempReset","sent","_sent","delegate","tryEntries","resetTryEntry","rootRecord","completion","rval","dispatchException","exception","loc","caught","record","entry","tryLoc","hasCatch","hasFinally","catchLoc","finallyLoc","finallyEntry","complete","afterLoc","thrown","delegateYield","iterable","resultName","nextLoc","protoGenerator","generator","_invoke","doneResult","delegateResult","maybeInvokeDelegate","tryCatch","makeInvokeMethod","previousPromise","callInvokeWithMethodAndArg","Promise","invoke","unwrapped","pushTryEntry","locs","iteratorMethod"],"mappings":"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","file":"static/js/2.724ade1fac9211f8b197.js","sourcesContent":["!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"codemirror\")):\"function\"==typeof define&&define.amd?define([\"codemirror\"],t):\"object\"==typeof exports?exports.VueCodemirror=t(require(\"codemirror\")):e.VueCodemirror=t(e.codemirror)}(this,function(e){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,\"a\",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=\"/\",t(t.s=3)}([function(t,n){t.exports=e},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var r=n(0),o=function(e){return e&&e.__esModule?e:{default:e}}(r),i=window.CodeMirror||o.default;\"function\"!=typeof Object.assign&&Object.defineProperty(Object,\"assign\",{value:function(e,t){if(null==e)throw new TypeError(\"Cannot convert undefined or null to object\");for(var n=Object(e),r=1;r<arguments.length;r++){var o=arguments[r];if(null!=o)for(var i in o)Object.prototype.hasOwnProperty.call(o,i)&&(n[i]=o[i])}return n},writable:!0,configurable:!0}),t.default={name:\"codemirror\",data:function(){return{content:\"\",codemirror:null,cminstance:null}},props:{code:String,value:String,marker:Function,unseenLines:Array,name:{type:String,default:\"codemirror\"},placeholder:{type:String,default:\"\"},merge:{type:Boolean,default:!1},options:{type:Object,default:function(){return{}}},events:{type:Array,default:function(){return[]}},globalOptions:{type:Object,default:function(){return{}}},globalEvents:{type:Array,default:function(){return[]}}},watch:{options:{deep:!0,handler:function(e){for(var t in e)this.cminstance.setOption(t,e[t])}},merge:function(){this.$nextTick(this.switchMerge)},code:function(e){this.handerCodeChange(e)},value:function(e){this.handerCodeChange(e)}},methods:{initialize:function(){var e=this,t=Object.assign({},this.globalOptions,this.options);this.merge?(this.codemirror=i.MergeView(this.$refs.mergeview,t),this.cminstance=this.codemirror.edit):(this.codemirror=i.fromTextArea(this.$refs.textarea,t),this.cminstance=this.codemirror,this.cminstance.setValue(this.code||this.value||this.content)),this.cminstance.on(\"change\",function(t){e.content=t.getValue(),e.$emit&&e.$emit(\"input\",e.content)});var n={};[\"scroll\",\"changes\",\"beforeChange\",\"cursorActivity\",\"keyHandled\",\"inputRead\",\"electricInput\",\"beforeSelectionChange\",\"viewportChange\",\"swapDoc\",\"gutterClick\",\"gutterContextMenu\",\"focus\",\"blur\",\"refresh\",\"optionChange\",\"scrollCursorIntoView\",\"update\"].concat(this.events).concat(this.globalEvents).filter(function(e){return!n[e]&&(n[e]=!0)}).forEach(function(t){e.cminstance.on(t,function(){for(var n=arguments.length,r=Array(n),o=0;o<n;o++)r[o]=arguments[o];e.$emit.apply(e,[t].concat(r));var i=t.replace(/([A-Z])/g,\"-$1\").toLowerCase();i!==t&&e.$emit.apply(e,[i].concat(r))})});this.$emit(\"ready\",this.codemirror),this.unseenLineMarkers(),this.refresh()},refresh:function(){var e=this;this.$nextTick(function(){e.cminstance.refresh()})},destroy:function(){var e=this.cminstance.doc.cm.getWrapperElement();e&&e.remove&&e.remove()},handerCodeChange:function(e){if(e!==this.cminstance.getValue()){var t=this.cminstance.getScrollInfo();this.cminstance.setValue(e),this.content=e,this.cminstance.scrollTo(t.left,t.top)}this.unseenLineMarkers()},unseenLineMarkers:function(){var e=this;void 0!==this.unseenLines&&void 0!==this.marker&&this.unseenLines.forEach(function(t){var n=e.cminstance.lineInfo(t);e.cminstance.setGutterMarker(t,\"breakpoints\",n.gutterMarkers?null:e.marker())})},switchMerge:function(){var e=this.cminstance.doc.history,t=this.cminstance.doc.cleanGeneration;this.options.value=this.cminstance.getValue(),this.destroy(),this.initialize(),this.cminstance.doc.history=e,this.cminstance.doc.cleanGeneration=t}},mounted:function(){this.initialize()},beforeDestroy:function(){this.destroy()}}},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var r=n(1),o=n.n(r);for(var i in r)[\"default\",\"default\"].indexOf(i)<0&&function(e){n.d(t,e,function(){return r[e]})}(i);var s=n(5),c=n(4),a=c(o.a,s.a,!1,null,null,null);t.default=a.exports},function(e,t,n){\"use strict\";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,\"__esModule\",{value:!0}),t.install=t.codemirror=t.CodeMirror=void 0;var o=n(0),i=r(o),s=n(2),c=r(s),a=window.CodeMirror||i.default,u=function(e,t){t&&(t.options&&(c.default.props.globalOptions.default=function(){return t.options}),t.events&&(c.default.props.globalEvents.default=function(){return t.events})),e.component(c.default.name,c.default)},l={CodeMirror:a,codemirror:c.default,install:u};t.default=l,t.CodeMirror=a,t.codemirror=c.default,t.install=u},function(e,t){e.exports=function(e,t,n,r,o,i){var s,c=e=e||{},a=typeof e.default;\"object\"!==a&&\"function\"!==a||(s=e,c=e.default);var u=\"function\"==typeof c?c.options:c;t&&(u.render=t.render,u.staticRenderFns=t.staticRenderFns,u._compiled=!0),n&&(u.functional=!0),o&&(u._scopeId=o);var l;if(i?(l=function(e){e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,e||\"undefined\"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),r&&r.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(i)},u._ssrRegister=l):r&&(l=r),l){var f=u.functional,d=f?u.render:u.beforeCreate;f?(u._injectStyles=l,u.render=function(e,t){return l.call(t),d(e,t)}):u.beforeCreate=d?[].concat(d,l):[l]}return{esModule:s,exports:c,options:u}}},function(e,t,n){\"use strict\";var r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n(\"div\",{staticClass:\"vue-codemirror\",class:{merge:e.merge}},[e.merge?n(\"div\",{ref:\"mergeview\"}):n(\"textarea\",{ref:\"textarea\",attrs:{name:e.name,placeholder:e.placeholder}})])},o=[],i={render:r,staticRenderFns:o};t.a=i}])});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_vue-codemirror@4.0.6@vue-codemirror/dist/vue-codemirror.js\n// module id = 2RDZ\n// module chunks = 2","\"use strict\";\n\nexports.__esModule = true;\n\nvar _promise = require(\"../core-js/promise\");\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new _promise2.default(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return _promise2.default.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_babel-runtime@6.26.0@babel-runtime/helpers/asyncToGenerator.js\n// module id = J0Oq\n// module chunks = 2","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n    if (self.time <= +new Date) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date);\n    }\n  };\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date + ms;\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers || (emitter._handlers = {});\n      map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range$$1;\n    try {range$$1 = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range$$1 || range$$1.parentElement() != te) { return false }\n    return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n      var this$1 = this;\n\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n      var this$1 = this;\n\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this$1.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n    var line = getLine(doc, lineNo$$1);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i < lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) > lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map$$1, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map$$1.length; i += 3) {\n      mStart = map$$1[i];\n      mEnd = map$$1[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map$$1[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n            node = map$$1[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n            node = map$$1[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = outside; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight$$1 = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range$$1 = doc.sel.ranges[i];\n      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range$$1.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range$$1.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range$$1, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range$$1, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range$$1.from(), sTo = range$$1.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n        cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      onBlur(cm);\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range$$1) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range$$1;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range$$1 = cm.curOp.scrollToPos;\n    if (range$$1) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n      scrollToCoordsRange(cm, from, to, range$$1.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n      var this$1 = this;\n\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this$1.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range$$1 = document.createRange();\n      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range$$1.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range$$1);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true\n    }\n    return false\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [], sawLineNumbers = false;\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i], style = null;\n      if (typeof name != \"string\") { style = name.style; name = name.className; }\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) { continue }\n        else { sawLineNumbers = true; }\n      }\n      result.push({className: name, style: style});\n    }\n    if (lineNumbers && !sawLineNumbers) { result.push({className: \"CodeMirror-linenumbers\", style: null}); }\n    return result\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function renderGutters(display) {\n    var gutters = display.gutters, specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n      if (style) { gElt.style.cssText = style; }\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n\n    input.init(d);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n      var this$1 = this;\n\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this$1.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n      var this$1 = this;\n\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n      var this$1 = this;\n\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this$1.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n      var this$1 = this;\n\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this$1.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight$$1);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        var this$1 = this;\n\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n\n      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n      // is with selectLeft/Right\n      var preventCursorLeft = (\"selectLeft\" in m) ? !m.selectLeft : m.inclusiveLeft;\n      var preventCursorRight = (\"selectRight\" in m) ? !m.selectRight : m.inclusiveRight;\n\n      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? preventCursorRight : preventCursorLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? preventCursorLeft : preventCursorRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))\n      { doc.cantEdit = false; }\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    var this$1 = this;\n\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this$1;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this$1.lines[i];\n        this$1.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var e = at + n; at < e; ++at)\n        { if (op(this$1.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    var this$1 = this;\n\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this$1;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this$1.height -= oldHeight - child.height;\n          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this$1.children.splice(++i, 0, leaf);\n              leaf.parent = this$1;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this$1.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    var this$1 = this;\n\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this$1[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n      var this$1 = this;\n\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n      var this$1 = this;\n\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    var this$1 = this;\n\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this$1; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this$1.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range$$1 = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range$$1.head; }\n      else if (start == \"anchor\") { pos = range$$1.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n      else { pos = range$$1.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      var this$1 = this;\n\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                           clipPos(this$1, ranges[i].head)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var this$1 = this;\n\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var this$1 = this;\n\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var this$1 = this;\n\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range$$1 = sel.ranges[i];\n        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this$1, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo$$1 = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n                span.from == null && lineNo$$1 != from.line ||\n                span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo$$1;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo$$1;\n      });\n      return clipPos(this, Pos(lineNo$$1, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      var this$1 = this;\n\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this$1.linked[i];\n        if (link.doc != other) { continue }\n        this$1.linked.splice(i, 1);\n        other.unlinkDoc(this$1);\n        detachSharedMarkers(findSharedMarkers(this$1));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          { return }\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map$$1, handle, context) {\n    map$$1 = getKeyMap(map$$1);\n    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map$$1.fallthrough) {\n      if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map$$1.fallthrough, handle, context) }\n      for (var i = 0; i < map$$1.fallthrough.length; i++) {\n        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    delayBlurEvent(cm);\n    setTimeout(function () { return display.input.focus(); }, 20);\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range$$1 = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n      else\n        { ourRange = range$$1; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range$$1.anchor, anchor) > 0) {\n          head = range$$1.head;\n          anchor = minPos(oldRange.from(), range$$1.anchor);\n        } else {\n          head = range$$1.anchor;\n          anchor = maxPos(oldRange.to(), range$$1.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range$$1) {\n    var anchor = range$$1.anchor;\n    var head = range$$1.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\n    var order = getOrder(anchorLine);\n    if (!order) { return range$$1 }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range$$1 }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(bind(onFocus, this), 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this$1, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range$$1 = sel.ranges[i$1];\n      var from = range$$1.from(), to = range$$1.to();\n      if (range$$1.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range$$1 = sel.ranges[i];\n      if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n      var mode = cm.getModeAt(range$$1.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range$$1.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n          { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map$$1, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n      },\n      removeKeyMap: function(map$$1) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var this$1 = this;\n\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this$1.state.modeGen++;\n            regChange(this$1);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var this$1 = this;\n\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range$$1 = ranges[i];\n          if (!range$$1.empty()) {\n            var from = range$$1.from(), to = range$$1.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this$1, j, how); }\n            var newRanges = this$1.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range$$1.head.line > end) {\n            indentLine(this$1, range$$1.head.line, how, true);\n            end = range$$1.head.line;\n            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var this$1 = this;\n\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range$$1 = this.doc.sel.primary();\n        if (start == null) { pos = range$$1.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range$$1.from() : range$$1.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var this$1 = this;\n\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this$1.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range$$1) {\n          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range$$1.from() : range$$1.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range$$1) {\n            var other = findPosH(doc, range$$1.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var this$1 = this;\n\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this$1, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this$1, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range$$1) {\n          if (collapse)\n            { return dir < 0 ? range$$1.from() : range$$1.to() }\n          var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range$$1 == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range$$1, margin) {\n        if (range$$1 == null) {\n          range$$1 = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range$$1 == \"number\") {\n          range$$1 = {from: Pos(range$$1, 0), to: null};\n        } else if (range$$1.from == null) {\n          range$$1 = {from: range$$1, to: null};\n        }\n        if (!range$$1.to) { range$$1.to = range$$1.from; }\n        range$$1.margin = margin || 0;\n\n        if (range$$1.from.line != null) {\n          scrollToRange(this, range$$1);\n        } else {\n          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo$$1 = this.display.viewFrom;\n        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n          ++lineNo$$1;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        // Cancel the current text selection if any (#5821)\n        if (this.state.selectingText) { this.state.selectingText(); }\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    function findNextLine() {\n      var l = pos.line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    on(div, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = document.activeElement;\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = this.cm.state.focused;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor())\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range$$1 = found[0].find(0)))\n            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map$$1 = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map$$1.length; j += 3) {\n          var curNode = map$$1[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map$$1[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, …*/) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.49.2\";\n\n  return CodeMirror;\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_codemirror@5.49.2@codemirror/lib/codemirror.js\n// module id = Rttr\n// module chunks = 2","<template>\n    <div class=\"home h\">\n      <el-container class=\"h\">\n          <left-side @showmsg=\"getcomponentmsg\" :msg=\"msg\"></left-side>\n          <el-main>\n            <div class=\"breadcrumb\">\n              <el-breadcrumb separator=\"/\">\n                <el-breadcrumb-item :to=\"{ path: '/' }\">首页</el-breadcrumb-item>\n                <el-breadcrumb-item><a href=\"/\">文章</a></el-breadcrumb-item>\n                <el-breadcrumb-item>正文</el-breadcrumb-item>\n              </el-breadcrumb>\n            </div>\n\n            <div class=\"content\">\n              <h2>{{ title }}</h2>\n              <p>\n                <span>作者：{{ author }}</span>\n                <span>发布日期：{{ publishDate }}</span>\n                <span>浏览量：{{ viewCount }}</span>\n              </p>\n              <div class=\"con\" v-html=\"content\"></div>\n              <!-- <div class=\"con mt20\">\n                <h4>此处展示一下codemirror代码编辑器</h4>\n                <codemirror v-model=\"code\" :options=\"cmOptions\"></codemirror>\n              </div> -->\n              <div class=\"rate\">\n                <el-rate\n                  v-model=\"rate\"\n                  show-text>\n                </el-rate>\n              </div>\n              <p class=\"tc\">\n                <el-button type=\"warning\" icon=\"el-icon-share\">点赞（10）</el-button>\n                <el-button type=\"success\" icon=\"el-icon-star-off\" @click=\"showPayBox\">打赏</el-button>\n              </p>\n              <div class=\"comment-box\">\n                <h2>说点什么</h2>\n                <el-form ref=\"form\" :model=\"form\" label-width=\"80px\">\n                  <el-form-item label=\"昵称\">\n                    <el-input v-model=\"form.name\" placeholder=\"您的昵称\"></el-input>\n                  </el-form-item>\n                  <el-form-item label=\"邮箱\">\n                    <el-input v-model=\"form.email\" placeholder=\"您的常用邮箱\"></el-input>\n                  </el-form-item>\n                  <el-form-item label=\"链接\">\n                    <el-input v-model=\"form.url\" placeholder=\"您的网站链接\"></el-input>\n                  </el-form-item>\n                  <el-form-item label=\"内容\">\n                    <el-input type=\"textarea\" v-model=\"form.desc\" placeholder=\"说点啥吧，不然我都不知道你来过\"></el-input>\n                  </el-form-item>\n                  <el-form-item>\n                    <el-button type=\"primary\" @click=\"onSubmit\">提交</el-button>\n                  </el-form-item>\n                </el-form>\n              </div>\n            </div>\n            <foot></foot>\n          </el-main>\n      </el-container>\n    </div>\n</template>\n\n<script>\nimport leftSide from '@/components/aside.vue'\nimport foot from '@/components/footer.vue'\n// require component\nimport { codemirror } from 'vue-codemirror'\n// language js\nimport 'codemirror/mode/javascript/javascript.js'\n// require styles\nimport 'codemirror/lib/codemirror.css'\n// theme css\nimport 'codemirror/theme/base16-dark.css'\n\nexport default {\n  name: 'Single',\n  data () {\n    return {\n      msg: '',\n      id: '',\n      title: '',\n      author: '',\n      publishDate: '',\n      viewCount: '',\n      content: '',\n      fullscreenLoading: true,\n      rate: null,\n      form: {\n        name: '',\n        email: '',\n        url: '',\n        desc: ''\n      },\n      code: `const pluckDeep = key => obj => key.split(\".\").reduce((accum, key) => accum[key], obj)\n\nconst compose = (...fns) => res => fns.reduce((accum, next) => next(accum), res)\n\nconst unfold = (f, seed) => {\n  const go = (f, seed, acc) => {\n    const res = f(seed)\n    return res ? go(f, res[1], acc.concat([res[0]])) : acc\n  }\n  return go(f, seed, [])\n}`,\n      cmOptions: {\n        // codemirror options\n        tabSize: 4,\n        mode: 'text/javascript',\n        theme: 'base16-dark',\n        lineNumbers: true,\n        line: true,\n        readOnly: true\n      }\n    }\n  },\n  components: {\n    leftSide,\n    foot,\n    codemirror\n  },\n  mounted () {\n    this.fetchData()\n  },\n  methods: {\n    async fetchData () {\n      this.id = this.$route.params.id // 获取URL传过来的参数id\n      // 请求接口 获取详情数据 TODO\n      // 此处没有用mock，简单的模拟一下做演示\n      switch (this.id) {\n        case 1:\n          this.title = 'Vue的一些常见面试题'\n          break\n        case 2:\n          this.title = 'PDF.js和PDFObject.js的使用'\n          break\n        case 3:\n          this.title = 'Echarts图表练习篇：学习时长统计'\n          break\n        case 4:\n          this.title = '个人的一些js demo分享'\n          break\n      }\n      this.author = 'haibao'\n      this.publishDate = '2018-08-13'\n      this.viewCount = '200'\n      this.content = '<strong>当前文章的ID是：</strong>' + this.id\n    },\n    getcomponentmsg (msg) {\n      alert('我在详情页-----' + msg)\n    },\n    showPayBox () {\n      // 显示打赏弹出层\n      this.$alert('<strong>这里放支付宝和微信图片即可</strong>', '打赏支持', {\n        dangerouslyUseHTMLString: true\n      })\n    },\n    onSubmit () {\n      // TODO.\n      alert('submit')\n    }\n  }\n}\n</script>\n\n<style scoped>\n.breadcrumb {\n  background-color: #f2f2f2;\n  padding: 10px;\n}\n.content {\n  padding: 25px 0;\n  min-height: 450px;\n}\n.rate, .mt20 {\n  margin-top: 20px;\n}\n.comment-box {\n  margin-top: 40px;\n}\n.comment-box h2 {\n  margin-bottom: 20px;\n}\n.tc {\n  text-align: center;\n}\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/pages/post/single.vue","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"home h\"},[_c('el-container',{staticClass:\"h\"},[_c('left-side',{attrs:{\"msg\":_vm.msg},on:{\"showmsg\":_vm.getcomponentmsg}}),_vm._v(\" \"),_c('el-main',[_c('div',{staticClass:\"breadcrumb\"},[_c('el-breadcrumb',{attrs:{\"separator\":\"/\"}},[_c('el-breadcrumb-item',{attrs:{\"to\":{ path: '/' }}},[_vm._v(\"首页\")]),_vm._v(\" \"),_c('el-breadcrumb-item',[_c('a',{attrs:{\"href\":\"/\"}},[_vm._v(\"文章\")])]),_vm._v(\" \"),_c('el-breadcrumb-item',[_vm._v(\"正文\")])],1)],1),_vm._v(\" \"),_c('div',{staticClass:\"content\"},[_c('h2',[_vm._v(_vm._s(_vm.title))]),_vm._v(\" \"),_c('p',[_c('span',[_vm._v(\"作者：\"+_vm._s(_vm.author))]),_vm._v(\" \"),_c('span',[_vm._v(\"发布日期：\"+_vm._s(_vm.publishDate))]),_vm._v(\" \"),_c('span',[_vm._v(\"浏览量：\"+_vm._s(_vm.viewCount))])]),_vm._v(\" \"),_c('div',{staticClass:\"con\",domProps:{\"innerHTML\":_vm._s(_vm.content)}}),_vm._v(\" \"),_c('div',{staticClass:\"rate\"},[_c('el-rate',{attrs:{\"show-text\":\"\"},model:{value:(_vm.rate),callback:function ($$v) {_vm.rate=$$v},expression:\"rate\"}})],1),_vm._v(\" \"),_c('p',{staticClass:\"tc\"},[_c('el-button',{attrs:{\"type\":\"warning\",\"icon\":\"el-icon-share\"}},[_vm._v(\"点赞（10）\")]),_vm._v(\" \"),_c('el-button',{attrs:{\"type\":\"success\",\"icon\":\"el-icon-star-off\"},on:{\"click\":_vm.showPayBox}},[_vm._v(\"打赏\")])],1),_vm._v(\" \"),_c('div',{staticClass:\"comment-box\"},[_c('h2',[_vm._v(\"说点什么\")]),_vm._v(\" \"),_c('el-form',{ref:\"form\",attrs:{\"model\":_vm.form,\"label-width\":\"80px\"}},[_c('el-form-item',{attrs:{\"label\":\"昵称\"}},[_c('el-input',{attrs:{\"placeholder\":\"您的昵称\"},model:{value:(_vm.form.name),callback:function ($$v) {_vm.$set(_vm.form, \"name\", $$v)},expression:\"form.name\"}})],1),_vm._v(\" \"),_c('el-form-item',{attrs:{\"label\":\"邮箱\"}},[_c('el-input',{attrs:{\"placeholder\":\"您的常用邮箱\"},model:{value:(_vm.form.email),callback:function ($$v) {_vm.$set(_vm.form, \"email\", $$v)},expression:\"form.email\"}})],1),_vm._v(\" \"),_c('el-form-item',{attrs:{\"label\":\"链接\"}},[_c('el-input',{attrs:{\"placeholder\":\"您的网站链接\"},model:{value:(_vm.form.url),callback:function ($$v) {_vm.$set(_vm.form, \"url\", $$v)},expression:\"form.url\"}})],1),_vm._v(\" \"),_c('el-form-item',{attrs:{\"label\":\"内容\"}},[_c('el-input',{attrs:{\"type\":\"textarea\",\"placeholder\":\"说点啥吧，不然我都不知道你来过\"},model:{value:(_vm.form.desc),callback:function ($$v) {_vm.$set(_vm.form, \"desc\", $$v)},expression:\"form.desc\"}})],1),_vm._v(\" \"),_c('el-form-item',[_c('el-button',{attrs:{\"type\":\"primary\"},on:{\"click\":_vm.onSubmit}},[_vm._v(\"提交\")])],1)],1)],1)]),_vm._v(\" \"),_c('foot')],1)],1)],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_vue-loader@13.7.3@vue-loader/lib/template-compiler?{\"id\":\"data-v-519256c0\",\"hasScoped\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"},\"buble\":{\"transforms\":{}}}!./node_modules/_vue-loader@13.7.3@vue-loader/lib/selector.js?type=template&index=0!./src/pages/post/single.vue\n// module id = null\n// module chunks = ","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/_extract-text-webpack-plugin@3.0.2@extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"sourceMap\\\":true}!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-519256c0\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector?type=styles&index=0!./single.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/component-normalizer\")\n/* script */\nexport * from \"!!babel-loader!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector?type=script&index=0!./single.vue\"\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector?type=script&index=0!./single.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-519256c0\\\",\\\"hasScoped\\\":true,\\\"transformToRequire\\\":{\\\"video\\\":[\\\"src\\\",\\\"poster\\\"],\\\"source\\\":\\\"src\\\",\\\"img\\\":\\\"src\\\",\\\"image\\\":\\\"xlink:href\\\"},\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/_vue-loader@13.7.3@vue-loader/lib/selector?type=template&index=0!./single.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-519256c0\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/pages/post/single.vue\n// module id = null\n// module chunks = ","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_regenerator-runtime@0.11.1@regenerator-runtime/runtime-module.js\n// module id = XqSp\n// module chunks = 2","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d[\\d_]*(?:[eE][+\\-]?[\\d_]+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:n|(?:\\.[\\d_]*)?(?:[eE][+\\-]?[\\d_]+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (ch == \"<\" && stream.match(\"!--\") || ch == \"-\" && stream.match(\"->\")) {\n      stream.skipToEnd()\n      return ret(\"comment\", \"comment\")\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*.*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/`]/.test(ch)) {\n        for (;; --pos) {\n          if (pos == 0) return\n          var next = stream.string.charAt(pos - 1)\n          if (next == ch && stream.string.charAt(pos - 2) != \"\\\\\") { pos--; break }\n        }\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), expression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    if (type == \"import\") return cont(expression);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^>]|<.*?>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function maybetypeOrIn(type, value) {\n    if (isTS && (type == \":\" || value == \"in\")) return cont(typeexpr)\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\", \",;\"), poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetypeOrIn, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(isTS ? classfield : functiondef, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(isTS ? classfield : functiondef, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), isTS ? classfield : functiondef, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_codemirror@5.49.2@codemirror/mode/javascript/javascript.js\n// module id = k6J1\n// module chunks = 2","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_regenerator-runtime@0.11.1@regenerator-runtime/runtime.js\n// module id = k9rz\n// module chunks = 2","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_babel-runtime@6.26.0@babel-runtime/regenerator/index.js\n// module id = lC5x\n// module chunks = 2"],"sourceRoot":""}